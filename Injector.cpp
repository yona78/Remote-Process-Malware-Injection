//#undef UNICODE
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <iostream>
#include <tlhelp32.h>
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
using namespace std;

#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")
#define NAMEDLL "DLLFINAL.dll"

int main() {
	HANDLE hProcessSnap;
	PROCESSENTRY32 pe32;
	DWORD result1 = NULL;
	CHAR dll[81];
	GetFullPathNameA(NAMEDLL, 81, dll, NULL);
	// Take a snapshot of all processes in the system.
	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hProcessSnap) return(FALSE);

	pe32.dwSize = sizeof(PROCESSENTRY32); // <----- IMPORTANT

	// Retrieve information about the first process,
	// and exit if unsuccessful
	if (!Process32First(hProcessSnap, &pe32))
	{
		CloseHandle(hProcessSnap);          // clean the snapshot object
		printf("!!! Failed to gather information on system processes! \n");
		return(NULL);
	}

	do
	{
		if (0 == strcmp((const char*)L"notepad.exe", (const char*)pe32.szExeFile))
		{
			result1 = pe32.th32ProcessID;
			break;
		}
	} while (Process32Next(hProcessSnap, &pe32));

	CloseHandle(hProcessSnap);
	if (result1 == NULL)
	{
		cout << "no such process like notepad" << endl;
		return 0;
	}
	// Get full path of DLL to inject  
	DWORD pathLen = GetFullPathNameA(NAMEDLL, 0, NULL, NULL);
	// Get LoadLibrary function address â€“      // the address doesn't change at remote process    
	PVOID addrLoadLibrary = (PVOID)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryA");
	// Open remote process     
	HANDLE proc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, result1);

	// Get a pointer to memory location in remote process,     
	// big enough to store DLL path    
	PVOID memAddr = (PVOID)VirtualAllocEx(proc, NULL, pathLen, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (NULL == memAddr) {
		DWORD err = GetLastError();
		return 0;
	}      // Write DLL name to remote process memory   
	BOOL check = WriteProcessMemory(proc, memAddr, dll, pathLen, NULL);
	if (0 == check)
	{
		DWORD err = GetLastError();
		return 0;
	}
	// Open remote thread, while executing LoadLibrary     
	// with parameter DLL name, will trigger DLLMain 
	HANDLE hRemote = CreateRemoteThread(proc, NULL, 0, (LPTHREAD_START_ROUTINE)addrLoadLibrary, (LPVOID)memAddr, 0, NULL);
	if (NULL == hRemote)
	{
		DWORD err = GetLastError();
		return 0;
	}
	WaitForSingleObject(hRemote, INFINITE);
	check = CloseHandle(hRemote);
	return 0;
}

